/*!
 * Author : Matteo Bruni
 * MIT license: https://opensource.org/licenses/MIT
 * Demo / Generator : https://particles.js.org/
 * GitHub : https://www.github.com/matteobruni/tsparticles
 * How to use? : Check the GitHub README
 * v3.3.0
 */
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(this["webpackChunk_tsparticles_plugin_absorbers"] = this["webpackChunk_tsparticles_plugin_absorbers"] || []).push([["dist_browser_AbsorberInstance_js"],{

/***/ "./dist/browser/AbsorberInstance.js":
/*!******************************************!*\
  !*** ./dist/browser/AbsorberInstance.js ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AbsorberInstance: () => (/* binding */ AbsorberInstance)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"@tsparticles/engine\");\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _Options_Classes_Absorber_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Options/Classes/Absorber.js */ \"./dist/browser/Options/Classes/Absorber.js\");\n\n\nconst squareExp = 2,\n  absorbFactor = 0.033,\n  minOrbitLength = 0,\n  minRadius = 0,\n  minMass = 0,\n  origin = {\n    x: 0,\n    y: 0\n  },\n  minAngle = 0,\n  double = 2,\n  maxAngle = Math.PI * double,\n  minVelocity = 0;\nclass AbsorberInstance {\n  constructor(absorbers, container, options, position) {\n    this.absorbers = absorbers;\n    this.container = container;\n    this._calcPosition = () => {\n      const exactPosition = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.calcPositionOrRandomFromSizeRanged)({\n        size: this.container.canvas.size,\n        position: this.options.position\n      });\n      return _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.create(exactPosition.x, exactPosition.y);\n    };\n    this._updateParticlePosition = (particle, v) => {\n      if (particle.destroyed) {\n        return;\n      }\n      const container = this.container,\n        canvasSize = container.canvas.size;\n      if (particle.needsNewPosition) {\n        const newPosition = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.calcPositionOrRandomFromSize)({\n          size: canvasSize\n        });\n        particle.position.setTo(newPosition);\n        particle.velocity.setTo(particle.initialVelocity);\n        particle.absorberOrbit = undefined;\n        particle.needsNewPosition = false;\n      }\n      if (this.options.orbits) {\n        if (particle.absorberOrbit === undefined) {\n          particle.absorberOrbit = _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin;\n          particle.absorberOrbit.length = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistance)(particle.getPosition(), this.position);\n          particle.absorberOrbit.angle = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * maxAngle;\n        }\n        if (particle.absorberOrbit.length <= this.size && !this.options.destroy) {\n          const minSize = Math.min(canvasSize.width, canvasSize.height),\n            offset = 1,\n            randomOffset = 0.1,\n            randomFactor = 0.2;\n          particle.absorberOrbit.length = minSize * (offset + ((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * randomFactor - randomOffset));\n        }\n        if (particle.absorberOrbitDirection === undefined) {\n          particle.absorberOrbitDirection = particle.velocity.x >= minVelocity ? \"clockwise\" : \"counter-clockwise\";\n        }\n        const orbitRadius = particle.absorberOrbit.length,\n          orbitAngle = particle.absorberOrbit.angle,\n          orbitDirection = particle.absorberOrbitDirection;\n        particle.velocity.setTo(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin);\n        const updateFunc = {\n          x: orbitDirection === \"clockwise\" ? Math.cos : Math.sin,\n          y: orbitDirection === \"clockwise\" ? Math.sin : Math.cos\n        };\n        particle.position.x = this.position.x + orbitRadius * updateFunc.x(orbitAngle);\n        particle.position.y = this.position.y + orbitRadius * updateFunc.y(orbitAngle);\n        particle.absorberOrbit.length -= v.length;\n        particle.absorberOrbit.angle += (particle.retina.moveSpeed ?? minVelocity) * container.retina.pixelRatio / _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.percentDenominator * container.retina.reduceFactor;\n      } else {\n        const addV = _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin;\n        addV.length = v.length;\n        addV.angle = v.angle;\n        particle.velocity.addTo(addV);\n      }\n    };\n    this.initialPosition = position ? _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.create(position.x, position.y) : undefined;\n    if (options instanceof _Options_Classes_Absorber_js__WEBPACK_IMPORTED_MODULE_1__.Absorber) {\n      this.options = options;\n    } else {\n      this.options = new _Options_Classes_Absorber_js__WEBPACK_IMPORTED_MODULE_1__.Absorber();\n      this.options.load(options);\n    }\n    this.dragging = false;\n    this.name = this.options.name;\n    this.opacity = this.options.opacity;\n    this.size = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRangeValue)(this.options.size.value) * container.retina.pixelRatio;\n    this.mass = this.size * this.options.size.density * container.retina.reduceFactor;\n    const limit = this.options.size.limit;\n    this.limit = {\n      radius: limit.radius * container.retina.pixelRatio * container.retina.reduceFactor,\n      mass: limit.mass\n    };\n    this.color = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.rangeColorToRgb)(this.options.color) ?? {\n      b: 0,\n      g: 0,\n      r: 0\n    };\n    this.position = this.initialPosition?.copy() ?? this._calcPosition();\n  }\n  attract(particle) {\n    const container = this.container,\n      options = this.options;\n    if (options.draggable) {\n      const mouse = container.interactivity.mouse;\n      if (mouse.clicking && mouse.downPosition) {\n        const mouseDist = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistance)(this.position, mouse.downPosition);\n        if (mouseDist <= this.size) {\n          this.dragging = true;\n        }\n      } else {\n        this.dragging = false;\n      }\n      if (this.dragging && mouse.position) {\n        this.position.x = mouse.position.x;\n        this.position.y = mouse.position.y;\n      }\n    }\n    const pos = particle.getPosition(),\n      {\n        dx,\n        dy,\n        distance\n      } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(this.position, pos),\n      v = _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.create(dx, dy);\n    v.length = this.mass / Math.pow(distance, squareExp) * container.retina.reduceFactor;\n    if (distance < this.size + particle.getRadius()) {\n      const sizeFactor = particle.getRadius() * absorbFactor * container.retina.pixelRatio;\n      if (this.size > particle.getRadius() && distance < this.size - particle.getRadius() || particle.absorberOrbit !== undefined && particle.absorberOrbit.length < minOrbitLength) {\n        if (options.destroy) {\n          particle.destroy();\n        } else {\n          particle.needsNewPosition = true;\n          this._updateParticlePosition(particle, v);\n        }\n      } else {\n        if (options.destroy) {\n          particle.size.value -= sizeFactor;\n        }\n        this._updateParticlePosition(particle, v);\n      }\n      if (this.limit.radius <= minRadius || this.size < this.limit.radius) {\n        this.size += sizeFactor;\n      }\n      if (this.limit.mass <= minMass || this.mass < this.limit.mass) {\n        this.mass += sizeFactor * this.options.size.density * container.retina.reduceFactor;\n      }\n    } else {\n      this._updateParticlePosition(particle, v);\n    }\n  }\n  draw(context) {\n    context.translate(this.position.x, this.position.y);\n    context.beginPath();\n    context.arc(origin.x, origin.y, this.size, minAngle, maxAngle, false);\n    context.closePath();\n    context.fillStyle = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getStyleFromRgb)(this.color, this.opacity);\n    context.fill();\n  }\n  resize() {\n    const initialPosition = this.initialPosition;\n    this.position = initialPosition && (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isPointInside)(initialPosition, this.container.canvas.size, _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin) ? initialPosition : this._calcPosition();\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/plugin-absorbers/./dist/browser/AbsorberInstance.js?");

/***/ })

}]);