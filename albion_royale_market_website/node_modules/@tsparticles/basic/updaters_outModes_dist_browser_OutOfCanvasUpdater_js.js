/*!
 * Author : Matteo Bruni
 * MIT license: https://opensource.org/licenses/MIT
 * Demo / Generator : https://particles.js.org/
 * GitHub : https://www.github.com/matteobruni/tsparticles
 * How to use? : Check the GitHub README
 * v3.3.0
 */
"use strict";
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(this["webpackChunk_tsparticles_basic"] = this["webpackChunk_tsparticles_basic"] || []).push([["updaters_outModes_dist_browser_OutOfCanvasUpdater_js"],{

/***/ "../../updaters/outModes/dist/browser/BounceOutMode.js":
/*!*************************************************************!*\
  !*** ../../updaters/outModes/dist/browser/BounceOutMode.js ***!
  \*************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BounceOutMode: () => (/* binding */ BounceOutMode)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n/* harmony import */ var _Utils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Utils.js */ \"../../updaters/outModes/dist/browser/Utils.js\");\n\n\nclass BounceOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [\"bounce\", \"split\"];\n  }\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    const container = this.container;\n    let handled = false;\n    for (const [, plugin] of container.plugins) {\n      if (plugin.particleBounce !== undefined) {\n        handled = plugin.particleBounce(particle, delta, direction);\n      }\n      if (handled) {\n        break;\n      }\n    }\n    if (handled) {\n      return;\n    }\n    const pos = particle.getPosition(),\n      offset = particle.offset,\n      size = particle.getRadius(),\n      bounds = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.calculateBounds)(pos, size),\n      canvasSize = container.canvas.size;\n    (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.bounceHorizontal)({\n      particle,\n      outMode,\n      direction,\n      bounds,\n      canvasSize,\n      offset,\n      size\n    });\n    (0,_Utils_js__WEBPACK_IMPORTED_MODULE_1__.bounceVertical)({\n      particle,\n      outMode,\n      direction,\n      bounds,\n      canvasSize,\n      offset,\n      size\n    });\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/basic/../../updaters/outModes/dist/browser/BounceOutMode.js?");

/***/ }),

/***/ "../../updaters/outModes/dist/browser/DestroyOutMode.js":
/*!**************************************************************!*\
  !*** ../../updaters/outModes/dist/browser/DestroyOutMode.js ***!
  \**************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DestroyOutMode: () => (/* binding */ DestroyOutMode)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n\nconst minVelocity = 0;\nclass DestroyOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [\"destroy\"];\n  }\n  update(particle, direction, _delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    const container = this.container;\n    switch (particle.outType) {\n      case \"normal\":\n      case \"outside\":\n        if ((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isPointInside)(particle.position, container.canvas.size, _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin, particle.getRadius(), direction)) {\n          return;\n        }\n        break;\n      case \"inside\":\n        {\n          const {\n              dx,\n              dy\n            } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(particle.position, particle.moveCenter),\n            {\n              x: vx,\n              y: vy\n            } = particle.velocity;\n          if (vx < minVelocity && dx > particle.moveCenter.radius || vy < minVelocity && dy > particle.moveCenter.radius || vx >= minVelocity && dx < -particle.moveCenter.radius || vy >= minVelocity && dy < -particle.moveCenter.radius) {\n            return;\n          }\n          break;\n        }\n    }\n    container.particles.remove(particle, undefined, true);\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/basic/../../updaters/outModes/dist/browser/DestroyOutMode.js?");

/***/ }),

/***/ "../../updaters/outModes/dist/browser/NoneOutMode.js":
/*!***********************************************************!*\
  !*** ../../updaters/outModes/dist/browser/NoneOutMode.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   NoneOutMode: () => (/* binding */ NoneOutMode)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n\nconst minVelocity = 0;\nclass NoneOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [\"none\"];\n  }\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    if ((particle.options.move.distance.horizontal && (direction === \"left\" || direction === \"right\")) ?? (particle.options.move.distance.vertical && (direction === \"top\" || direction === \"bottom\"))) {\n      return;\n    }\n    const gravityOptions = particle.options.move.gravity,\n      container = this.container,\n      canvasSize = container.canvas.size,\n      pRadius = particle.getRadius();\n    if (!gravityOptions.enable) {\n      if (particle.velocity.y > minVelocity && particle.position.y <= canvasSize.height + pRadius || particle.velocity.y < minVelocity && particle.position.y >= -pRadius || particle.velocity.x > minVelocity && particle.position.x <= canvasSize.width + pRadius || particle.velocity.x < minVelocity && particle.position.x >= -pRadius) {\n        return;\n      }\n      if (!(0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isPointInside)(particle.position, container.canvas.size, _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin, pRadius, direction)) {\n        container.particles.remove(particle);\n      }\n    } else {\n      const position = particle.position;\n      if (!gravityOptions.inverse && position.y > canvasSize.height + pRadius && direction === \"bottom\" || gravityOptions.inverse && position.y < -pRadius && direction === \"top\") {\n        container.particles.remove(particle);\n      }\n    }\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/basic/../../updaters/outModes/dist/browser/NoneOutMode.js?");

/***/ }),

/***/ "../../updaters/outModes/dist/browser/OutOfCanvasUpdater.js":
/*!******************************************************************!*\
  !*** ../../updaters/outModes/dist/browser/OutOfCanvasUpdater.js ***!
  \******************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OutOfCanvasUpdater: () => (/* binding */ OutOfCanvasUpdater)\n/* harmony export */ });\n/* harmony import */ var _BounceOutMode_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./BounceOutMode.js */ \"../../updaters/outModes/dist/browser/BounceOutMode.js\");\n/* harmony import */ var _DestroyOutMode_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./DestroyOutMode.js */ \"../../updaters/outModes/dist/browser/DestroyOutMode.js\");\n/* harmony import */ var _NoneOutMode_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./NoneOutMode.js */ \"../../updaters/outModes/dist/browser/NoneOutMode.js\");\n/* harmony import */ var _OutOutMode_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./OutOutMode.js */ \"../../updaters/outModes/dist/browser/OutOutMode.js\");\n\n\n\n\nconst checkOutMode = (outModes, outMode) => {\n  return outModes.default === outMode || outModes.bottom === outMode || outModes.left === outMode || outModes.right === outMode || outModes.top === outMode;\n};\nclass OutOfCanvasUpdater {\n  constructor(container) {\n    this._updateOutMode = (particle, delta, outMode, direction) => {\n      for (const updater of this.updaters) {\n        updater.update(particle, direction, delta, outMode);\n      }\n    };\n    this.container = container;\n    this.updaters = [];\n  }\n  init(particle) {\n    this.updaters = [];\n    const outModes = particle.options.move.outModes;\n    if (checkOutMode(outModes, \"bounce\")) {\n      this.updaters.push(new _BounceOutMode_js__WEBPACK_IMPORTED_MODULE_0__.BounceOutMode(this.container));\n    } else if (checkOutMode(outModes, \"out\")) {\n      this.updaters.push(new _OutOutMode_js__WEBPACK_IMPORTED_MODULE_3__.OutOutMode(this.container));\n    } else if (checkOutMode(outModes, \"destroy\")) {\n      this.updaters.push(new _DestroyOutMode_js__WEBPACK_IMPORTED_MODULE_1__.DestroyOutMode(this.container));\n    } else if (checkOutMode(outModes, \"none\")) {\n      this.updaters.push(new _NoneOutMode_js__WEBPACK_IMPORTED_MODULE_2__.NoneOutMode(this.container));\n    }\n  }\n  isEnabled(particle) {\n    return !particle.destroyed && !particle.spawning;\n  }\n  update(particle, delta) {\n    const outModes = particle.options.move.outModes;\n    this._updateOutMode(particle, delta, outModes.bottom ?? outModes.default, \"bottom\");\n    this._updateOutMode(particle, delta, outModes.left ?? outModes.default, \"left\");\n    this._updateOutMode(particle, delta, outModes.right ?? outModes.default, \"right\");\n    this._updateOutMode(particle, delta, outModes.top ?? outModes.default, \"top\");\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/basic/../../updaters/outModes/dist/browser/OutOfCanvasUpdater.js?");

/***/ }),

/***/ "../../updaters/outModes/dist/browser/OutOutMode.js":
/*!**********************************************************!*\
  !*** ../../updaters/outModes/dist/browser/OutOutMode.js ***!
  \**********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OutOutMode: () => (/* binding */ OutOutMode)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n\nconst minVelocity = 0,\n  minDistance = 0;\nclass OutOutMode {\n  constructor(container) {\n    this.container = container;\n    this.modes = [\"out\"];\n  }\n  update(particle, direction, delta, outMode) {\n    if (!this.modes.includes(outMode)) {\n      return;\n    }\n    const container = this.container;\n    switch (particle.outType) {\n      case \"inside\":\n        {\n          const {\n            x: vx,\n            y: vy\n          } = particle.velocity;\n          const circVec = _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin;\n          circVec.length = particle.moveCenter.radius;\n          circVec.angle = particle.velocity.angle + Math.PI;\n          circVec.addTo(_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.create(particle.moveCenter));\n          const {\n            dx,\n            dy\n          } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(particle.position, circVec);\n          if (vx <= minVelocity && dx >= minDistance || vy <= minVelocity && dy >= minDistance || vx >= minVelocity && dx <= minDistance || vy >= minVelocity && dy <= minDistance) {\n            return;\n          }\n          particle.position.x = Math.floor((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.randomInRange)({\n            min: 0,\n            max: container.canvas.size.width\n          }));\n          particle.position.y = Math.floor((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.randomInRange)({\n            min: 0,\n            max: container.canvas.size.height\n          }));\n          const {\n            dx: newDx,\n            dy: newDy\n          } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(particle.position, particle.moveCenter);\n          particle.direction = Math.atan2(-newDy, -newDx);\n          particle.velocity.angle = particle.direction;\n          break;\n        }\n      default:\n        {\n          if ((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.isPointInside)(particle.position, container.canvas.size, _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.Vector.origin, particle.getRadius(), direction)) {\n            return;\n          }\n          switch (particle.outType) {\n            case \"outside\":\n              {\n                particle.position.x = Math.floor((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.randomInRange)({\n                  min: -particle.moveCenter.radius,\n                  max: particle.moveCenter.radius\n                })) + particle.moveCenter.x;\n                particle.position.y = Math.floor((0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.randomInRange)({\n                  min: -particle.moveCenter.radius,\n                  max: particle.moveCenter.radius\n                })) + particle.moveCenter.y;\n                const {\n                  dx,\n                  dy\n                } = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getDistances)(particle.position, particle.moveCenter);\n                if (particle.moveCenter.radius) {\n                  particle.direction = Math.atan2(dy, dx);\n                  particle.velocity.angle = particle.direction;\n                }\n                break;\n              }\n            case \"normal\":\n              {\n                const warp = particle.options.move.warp,\n                  canvasSize = container.canvas.size,\n                  newPos = {\n                    bottom: canvasSize.height + particle.getRadius() + particle.offset.y,\n                    left: -particle.getRadius() - particle.offset.x,\n                    right: canvasSize.width + particle.getRadius() + particle.offset.x,\n                    top: -particle.getRadius() - particle.offset.y\n                  },\n                  sizeValue = particle.getRadius(),\n                  nextBounds = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.calculateBounds)(particle.position, sizeValue);\n                if (direction === \"right\" && nextBounds.left > canvasSize.width + particle.offset.x) {\n                  particle.position.x = newPos.left;\n                  particle.initialPosition.x = particle.position.x;\n                  if (!warp) {\n                    particle.position.y = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.height;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                } else if (direction === \"left\" && nextBounds.right < -particle.offset.x) {\n                  particle.position.x = newPos.right;\n                  particle.initialPosition.x = particle.position.x;\n                  if (!warp) {\n                    particle.position.y = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.height;\n                    particle.initialPosition.y = particle.position.y;\n                  }\n                }\n                if (direction === \"bottom\" && nextBounds.top > canvasSize.height + particle.offset.y) {\n                  if (!warp) {\n                    particle.position.x = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.width;\n                    particle.initialPosition.x = particle.position.x;\n                  }\n                  particle.position.y = newPos.top;\n                  particle.initialPosition.y = particle.position.y;\n                } else if (direction === \"top\" && nextBounds.bottom < -particle.offset.y) {\n                  if (!warp) {\n                    particle.position.x = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRandom)() * canvasSize.width;\n                    particle.initialPosition.x = particle.position.x;\n                  }\n                  particle.position.y = newPos.bottom;\n                  particle.initialPosition.y = particle.position.y;\n                }\n                break;\n              }\n          }\n          break;\n        }\n    }\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/basic/../../updaters/outModes/dist/browser/OutOutMode.js?");

/***/ }),

/***/ "../../updaters/outModes/dist/browser/Utils.js":
/*!*****************************************************!*\
  !*** ../../updaters/outModes/dist/browser/Utils.js ***!
  \*****************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bounceHorizontal: () => (/* binding */ bounceHorizontal),\n/* harmony export */   bounceVertical: () => (/* binding */ bounceVertical)\n/* harmony export */ });\n/* harmony import */ var _tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @tsparticles/engine */ \"../../engine/dist/browser/index.js\");\n\nconst minVelocity = 0,\n  boundsMin = 0;\nfunction bounceHorizontal(data) {\n  if (data.outMode !== \"bounce\" && data.outMode !== \"split\" || data.direction !== \"left\" && data.direction !== \"right\") {\n    return;\n  }\n  if (data.bounds.right < boundsMin && data.direction === \"left\") {\n    data.particle.position.x = data.size + data.offset.x;\n  } else if (data.bounds.left > data.canvasSize.width && data.direction === \"right\") {\n    data.particle.position.x = data.canvasSize.width - data.size - data.offset.x;\n  }\n  const velocity = data.particle.velocity.x;\n  let bounced = false;\n  if (data.direction === \"right\" && data.bounds.right >= data.canvasSize.width && velocity > minVelocity || data.direction === \"left\" && data.bounds.left <= boundsMin && velocity < minVelocity) {\n    const newVelocity = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRangeValue)(data.particle.options.bounce.horizontal.value);\n    data.particle.velocity.x *= -newVelocity;\n    bounced = true;\n  }\n  if (!bounced) {\n    return;\n  }\n  const minPos = data.offset.x + data.size;\n  if (data.bounds.right >= data.canvasSize.width && data.direction === \"right\") {\n    data.particle.position.x = data.canvasSize.width - minPos;\n  } else if (data.bounds.left <= boundsMin && data.direction === \"left\") {\n    data.particle.position.x = minPos;\n  }\n  if (data.outMode === \"split\") {\n    data.particle.destroy();\n  }\n}\nfunction bounceVertical(data) {\n  if (data.outMode !== \"bounce\" && data.outMode !== \"split\" || data.direction !== \"bottom\" && data.direction !== \"top\") {\n    return;\n  }\n  if (data.bounds.bottom < boundsMin && data.direction === \"top\") {\n    data.particle.position.y = data.size + data.offset.y;\n  } else if (data.bounds.top > data.canvasSize.height && data.direction === \"bottom\") {\n    data.particle.position.y = data.canvasSize.height - data.size - data.offset.y;\n  }\n  const velocity = data.particle.velocity.y;\n  let bounced = false;\n  if (data.direction === \"bottom\" && data.bounds.bottom >= data.canvasSize.height && velocity > minVelocity || data.direction === \"top\" && data.bounds.top <= boundsMin && velocity < minVelocity) {\n    const newVelocity = (0,_tsparticles_engine__WEBPACK_IMPORTED_MODULE_0__.getRangeValue)(data.particle.options.bounce.vertical.value);\n    data.particle.velocity.y *= -newVelocity;\n    bounced = true;\n  }\n  if (!bounced) {\n    return;\n  }\n  const minPos = data.offset.y + data.size;\n  if (data.bounds.bottom >= data.canvasSize.height && data.direction === \"bottom\") {\n    data.particle.position.y = data.canvasSize.height - minPos;\n  } else if (data.bounds.top <= boundsMin && data.direction === \"top\") {\n    data.particle.position.y = minPos;\n  }\n  if (data.outMode === \"split\") {\n    data.particle.destroy();\n  }\n}\n\n//# sourceURL=webpack://@tsparticles/basic/../../updaters/outModes/dist/browser/Utils.js?");

/***/ })

}]);