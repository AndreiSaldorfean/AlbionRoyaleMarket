{"ast":null,"code":"const DEFAULT_SPEED = 5.5;\nconst MEAN_DISTANCE = 913.2;\nclass Mount {\n  constructor(delay, moveBonus, gallopBonus, carryLoad) {\n    this.mountDelay = delay;\n    this.moveBonus = moveBonus;\n    this.gallopBonus = gallopBonus;\n    this.carryLoad = carryLoad;\n  }\n  travelTime() {\n    // The estimated value shall be only an estimation\n    const speed0 = DEFAULT_SPEED + DEFAULT_SPEED * this.moveBonus;\n    const speed1 = DEFAULT_SPEED + DEFAULT_SPEED * this.gallopBonus;\n    const timeFinal = (MEAN_DISTANCE - this.mountDelay * speed0) / speed1 + this.mountDelay;\n    return timeFinal / 60; // converting to minutes\n  }\n  cityTravelTime(map, startCity, destinationCity) {\n    console.log(startCity);\n    const tileTime = this.travelTime();\n    if (map[startCity][\"NeighbouringCities\"].hasOwnProperty(destinationCity)) {\n      return tileTime * map[startCity][\"NeighbouringCities\"][destinationCity];\n    } else {\n      let minDistance = 1000;\n      const neighbouringCities = map[startCity][\"NeighbouringCities\"];\n      let distanceFromStart = 0;\n      for (const index in neighbouringCities) {\n        const temp = neighbouringCities[index];\n        if (map[index][\"NeighbouringCities\"].hasOwnProperty(destinationCity) && minDistance > map[index][\"NeighbouringCities\"][destinationCity] + temp) {\n          minDistance = map[index][\"NeighbouringCities\"][destinationCity];\n          distanceFromStart = map[startCity][\"NeighbouringCities\"][index];\n        }\n      }\n      minDistance += distanceFromStart;\n      return tileTime * minDistance;\n    }\n  }\n  getCarryLoad() {\n    return this.carryLoad;\n  }\n}\nexport { Mount };","map":{"version":3,"names":["DEFAULT_SPEED","MEAN_DISTANCE","Mount","constructor","delay","moveBonus","gallopBonus","carryLoad","mountDelay","travelTime","speed0","speed1","timeFinal","cityTravelTime","map","startCity","destinationCity","console","log","tileTime","hasOwnProperty","minDistance","neighbouringCities","distanceFromStart","index","temp","getCarryLoad"],"sources":["C:/nginx/html/AlbionRoyaleMarket/albion_royale_market_website/src/scripts/classMount.js"],"sourcesContent":["const DEFAULT_SPEED = 5.5;\r\nconst MEAN_DISTANCE = 913.2;\r\n\r\nclass Mount {\r\n    constructor(delay, moveBonus, gallopBonus, carryLoad) {\r\n        this.mountDelay = delay;\r\n        this.moveBonus = moveBonus;\r\n        this.gallopBonus = gallopBonus;\r\n        this.carryLoad = carryLoad;\r\n    }\r\n\r\n    travelTime() {\r\n        // The estimated value shall be only an estimation\r\n        const speed0 = DEFAULT_SPEED + DEFAULT_SPEED * this.moveBonus;\r\n        const speed1 = DEFAULT_SPEED + DEFAULT_SPEED * this.gallopBonus;\r\n        const timeFinal = (MEAN_DISTANCE - this.mountDelay * speed0) / speed1 + this.mountDelay;\r\n        return timeFinal / 60; // converting to minutes\r\n    }\r\n\r\n    cityTravelTime(map, startCity, destinationCity) {\r\n        console.log(startCity);\r\n        const tileTime = this.travelTime();\r\n        if (map[startCity][\"NeighbouringCities\"].hasOwnProperty(destinationCity)) {\r\n            return tileTime * map[startCity][\"NeighbouringCities\"][destinationCity];\r\n        } else {\r\n            let minDistance = 1000;\r\n            const neighbouringCities = map[startCity][\"NeighbouringCities\"];\r\n            let distanceFromStart = 0;\r\n            for (const index in neighbouringCities) {\r\n                const temp = neighbouringCities[index];\r\n                if (map[index][\"NeighbouringCities\"].hasOwnProperty(destinationCity) &&\r\n                    minDistance > map[index][\"NeighbouringCities\"][destinationCity] + temp) {\r\n                    minDistance = map[index][\"NeighbouringCities\"][destinationCity];\r\n                    distanceFromStart = map[startCity][\"NeighbouringCities\"][index];\r\n                }\r\n            }\r\n            minDistance += distanceFromStart;\r\n            return tileTime * minDistance;\r\n        }\r\n    }\r\n\r\n    getCarryLoad() {\r\n        return this.carryLoad;\r\n    }\r\n}\r\nexport {Mount};"],"mappings":"AAAA,MAAMA,aAAa,GAAG,GAAG;AACzB,MAAMC,aAAa,GAAG,KAAK;AAE3B,MAAMC,KAAK,CAAC;EACRC,WAAWA,CAACC,KAAK,EAAEC,SAAS,EAAEC,WAAW,EAAEC,SAAS,EAAE;IAClD,IAAI,CAACC,UAAU,GAAGJ,KAAK;IACvB,IAAI,CAACC,SAAS,GAAGA,SAAS;IAC1B,IAAI,CAACC,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,SAAS,GAAGA,SAAS;EAC9B;EAEAE,UAAUA,CAAA,EAAG;IACT;IACA,MAAMC,MAAM,GAAGV,aAAa,GAAGA,aAAa,GAAG,IAAI,CAACK,SAAS;IAC7D,MAAMM,MAAM,GAAGX,aAAa,GAAGA,aAAa,GAAG,IAAI,CAACM,WAAW;IAC/D,MAAMM,SAAS,GAAG,CAACX,aAAa,GAAG,IAAI,CAACO,UAAU,GAAGE,MAAM,IAAIC,MAAM,GAAG,IAAI,CAACH,UAAU;IACvF,OAAOI,SAAS,GAAG,EAAE,CAAC,CAAC;EAC3B;EAEAC,cAAcA,CAACC,GAAG,EAAEC,SAAS,EAAEC,eAAe,EAAE;IAC5CC,OAAO,CAACC,GAAG,CAACH,SAAS,CAAC;IACtB,MAAMI,QAAQ,GAAG,IAAI,CAACV,UAAU,CAAC,CAAC;IAClC,IAAIK,GAAG,CAACC,SAAS,CAAC,CAAC,oBAAoB,CAAC,CAACK,cAAc,CAACJ,eAAe,CAAC,EAAE;MACtE,OAAOG,QAAQ,GAAGL,GAAG,CAACC,SAAS,CAAC,CAAC,oBAAoB,CAAC,CAACC,eAAe,CAAC;IAC3E,CAAC,MAAM;MACH,IAAIK,WAAW,GAAG,IAAI;MACtB,MAAMC,kBAAkB,GAAGR,GAAG,CAACC,SAAS,CAAC,CAAC,oBAAoB,CAAC;MAC/D,IAAIQ,iBAAiB,GAAG,CAAC;MACzB,KAAK,MAAMC,KAAK,IAAIF,kBAAkB,EAAE;QACpC,MAAMG,IAAI,GAAGH,kBAAkB,CAACE,KAAK,CAAC;QACtC,IAAIV,GAAG,CAACU,KAAK,CAAC,CAAC,oBAAoB,CAAC,CAACJ,cAAc,CAACJ,eAAe,CAAC,IAChEK,WAAW,GAAGP,GAAG,CAACU,KAAK,CAAC,CAAC,oBAAoB,CAAC,CAACR,eAAe,CAAC,GAAGS,IAAI,EAAE;UACxEJ,WAAW,GAAGP,GAAG,CAACU,KAAK,CAAC,CAAC,oBAAoB,CAAC,CAACR,eAAe,CAAC;UAC/DO,iBAAiB,GAAGT,GAAG,CAACC,SAAS,CAAC,CAAC,oBAAoB,CAAC,CAACS,KAAK,CAAC;QACnE;MACJ;MACAH,WAAW,IAAIE,iBAAiB;MAChC,OAAOJ,QAAQ,GAAGE,WAAW;IACjC;EACJ;EAEAK,YAAYA,CAAA,EAAG;IACX,OAAO,IAAI,CAACnB,SAAS;EACzB;AACJ;AACA,SAAQL,KAAK","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}