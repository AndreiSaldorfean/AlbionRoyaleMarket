{"version":3,"file":"static/js/4752.6bfc2ed3.chunk.js","mappings":"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","sources":["../node_modules/@tsparticles/shape-image/browser/GifUtils/Constants.js","../node_modules/@tsparticles/shape-image/browser/GifUtils/ByteStream.js","../node_modules/@tsparticles/shape-image/browser/GifUtils/Utils.js","../node_modules/@tsparticles/shape-image/browser/ImageDrawer.js"],"sourcesContent":["export const InterlaceOffsets = [0, 4, 2, 1];\nexport const InterlaceSteps = [8, 8, 4, 2];\n","export class ByteStream {\n    constructor(bytes) {\n        this.pos = 0;\n        this.data = new Uint8ClampedArray(bytes);\n    }\n    getString(count) {\n        const slice = this.data.slice(this.pos, this.pos + count);\n        this.pos += slice.length;\n        return slice.reduce((acc, curr) => acc + String.fromCharCode(curr), \"\");\n    }\n    nextByte() {\n        return this.data[this.pos++];\n    }\n    nextTwoBytes() {\n        const increment = 2, previous = 1, shift = 8;\n        this.pos += increment;\n        return this.data[this.pos - increment] + (this.data[this.pos - previous] << shift);\n    }\n    readSubBlocks() {\n        let blockString = \"\", size = 0;\n        const minCount = 0, emptySize = 0;\n        do {\n            size = this.data[this.pos++];\n            for (let count = size; --count >= minCount; blockString += String.fromCharCode(this.data[this.pos++])) {\n            }\n        } while (size !== emptySize);\n        return blockString;\n    }\n    readSubBlocksBin() {\n        let size = this.data[this.pos], len = 0;\n        const emptySize = 0, increment = 1;\n        for (let offset = 0; size !== emptySize; offset += size + increment, size = this.data[this.pos + offset]) {\n            len += size;\n        }\n        const blockData = new Uint8Array(len);\n        size = this.data[this.pos++];\n        for (let i = 0; size !== emptySize; size = this.data[this.pos++]) {\n            for (let count = size; --count >= emptySize; blockData[i++] = this.data[this.pos++]) {\n            }\n        }\n        return blockData;\n    }\n    skipSubBlocks() {\n        for (const increment = 1, noData = 0; this.data[this.pos] !== noData; this.pos += this.data[this.pos] + increment) {\n        }\n        this.pos++;\n    }\n}\n","import { InterlaceOffsets, InterlaceSteps } from \"./Constants.js\";\nimport { ByteStream } from \"./ByteStream.js\";\nconst origin = {\n    x: 0,\n    y: 0,\n}, defaultFrame = 0, half = 0.5, initialTime = 0, firstIndex = 0, defaultLoopCount = 0;\nfunction parseColorTable(byteStream, count) {\n    const colors = [];\n    for (let i = 0; i < count; i++) {\n        colors.push({\n            r: byteStream.data[byteStream.pos],\n            g: byteStream.data[byteStream.pos + 1],\n            b: byteStream.data[byteStream.pos + 2],\n        });\n        byteStream.pos += 3;\n    }\n    return colors;\n}\nfunction parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex) {\n    switch (byteStream.nextByte()) {\n        case 249: {\n            const frame = gif.frames[getFrameIndex(false)];\n            byteStream.pos++;\n            const packedByte = byteStream.nextByte();\n            frame.GCreserved = (packedByte & 0xe0) >>> 5;\n            frame.disposalMethod = (packedByte & 0x1c) >>> 2;\n            frame.userInputDelayFlag = (packedByte & 2) === 2;\n            const transparencyFlag = (packedByte & 1) === 1;\n            frame.delayTime = byteStream.nextTwoBytes() * 0xa;\n            const transparencyIndex = byteStream.nextByte();\n            if (transparencyFlag) {\n                getTransparencyIndex(transparencyIndex);\n            }\n            byteStream.pos++;\n            break;\n        }\n        case 255: {\n            byteStream.pos++;\n            const applicationExtension = {\n                identifier: byteStream.getString(8),\n                authenticationCode: byteStream.getString(3),\n                data: byteStream.readSubBlocksBin(),\n            };\n            gif.applicationExtensions.push(applicationExtension);\n            break;\n        }\n        case 254: {\n            gif.comments.push([getFrameIndex(false), byteStream.readSubBlocks()]);\n            break;\n        }\n        case 1: {\n            if (gif.globalColorTable.length === 0) {\n                throw new EvalError(\"plain text extension without global color table\");\n            }\n            byteStream.pos++;\n            gif.frames[getFrameIndex(false)].plainTextData = {\n                left: byteStream.nextTwoBytes(),\n                top: byteStream.nextTwoBytes(),\n                width: byteStream.nextTwoBytes(),\n                height: byteStream.nextTwoBytes(),\n                charSize: {\n                    width: byteStream.nextTwoBytes(),\n                    height: byteStream.nextTwoBytes(),\n                },\n                foregroundColor: byteStream.nextByte(),\n                backgroundColor: byteStream.nextByte(),\n                text: byteStream.readSubBlocks(),\n            };\n            break;\n        }\n        default:\n            byteStream.skipSubBlocks();\n            break;\n    }\n}\nasync function parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    const frame = gif.frames[getFrameIndex(true)];\n    frame.left = byteStream.nextTwoBytes();\n    frame.top = byteStream.nextTwoBytes();\n    frame.width = byteStream.nextTwoBytes();\n    frame.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), localColorTableFlag = (packedByte & 0x80) === 0x80, interlacedFlag = (packedByte & 0x40) === 0x40;\n    frame.sortFlag = (packedByte & 0x20) === 0x20;\n    frame.reserved = (packedByte & 0x18) >>> 3;\n    const localColorCount = 1 << ((packedByte & 7) + 1);\n    if (localColorTableFlag) {\n        frame.localColorTable = parseColorTable(byteStream, localColorCount);\n    }\n    const getColor = (index) => {\n        const { r, g, b } = (localColorTableFlag ? frame.localColorTable : gif.globalColorTable)[index];\n        if (index !== getTransparencyIndex(null)) {\n            return { r, g, b, a: 255 };\n        }\n        return { r, g, b, a: avgAlpha ? ~~((r + g + b) / 3) : 0 };\n    };\n    const image = (() => {\n        try {\n            return new ImageData(frame.width, frame.height, { colorSpace: \"srgb\" });\n        }\n        catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (image == null) {\n        throw new EvalError(\"GIF frame size is to large\");\n    }\n    const minCodeSize = byteStream.nextByte(), imageData = byteStream.readSubBlocksBin(), clearCode = 1 << minCodeSize;\n    const readBits = (pos, len) => {\n        const bytePos = pos >>> 3, bitPos = pos & 7;\n        return (((imageData[bytePos] + (imageData[bytePos + 1] << 8) + (imageData[bytePos + 2] << 16)) &\n            (((1 << len) - 1) << bitPos)) >>>\n            bitPos);\n    };\n    if (interlacedFlag) {\n        for (let code = 0, size = minCodeSize + 1, pos = 0, dic = [[0]], pass = 0; pass < 4; pass++) {\n            if (InterlaceOffsets[pass] < frame.height) {\n                let pixelPos = 0, lineIndex = 0, exit = false;\n                while (!exit) {\n                    const last = code;\n                    code = readBits(pos, size);\n                    pos += size + 1;\n                    if (code === clearCode) {\n                        size = minCodeSize + 1;\n                        dic.length = clearCode + 2;\n                        for (let i = 0; i < dic.length; i++) {\n                            dic[i] = i < clearCode ? [i] : [];\n                        }\n                    }\n                    else {\n                        if (code >= dic.length) {\n                            dic.push(dic[last].concat(dic[last][0]));\n                        }\n                        else if (last !== clearCode) {\n                            dic.push(dic[last].concat(dic[code][0]));\n                        }\n                        for (const item of dic[code]) {\n                            const { r, g, b, a } = getColor(item);\n                            image.data.set([r, g, b, a], InterlaceOffsets[pass] * frame.width +\n                                InterlaceSteps[pass] * lineIndex +\n                                (pixelPos % (frame.width * 4)));\n                            pixelPos += 4;\n                        }\n                        if (dic.length === 1 << size && size < 0xc) {\n                            size++;\n                        }\n                    }\n                    if (pixelPos === frame.width * 4 * (lineIndex + 1)) {\n                        lineIndex++;\n                        if (InterlaceOffsets[pass] + InterlaceSteps[pass] * lineIndex >= frame.height) {\n                            exit = true;\n                        }\n                    }\n                }\n            }\n            progressCallback?.(byteStream.pos / (byteStream.data.length - 1), getFrameIndex(false) + 1, image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n    }\n    else {\n        let code = 0, size = minCodeSize + 1, pos = 0, pixelPos = -4, exit = false;\n        const dic = [[0]];\n        while (!exit) {\n            const last = code;\n            code = readBits(pos, size);\n            pos += size;\n            if (code === clearCode) {\n                size = minCodeSize + 1;\n                dic.length = clearCode + 2;\n                for (let i = 0; i < dic.length; i++) {\n                    dic[i] = i < clearCode ? [i] : [];\n                }\n            }\n            else {\n                if (code === clearCode + 1) {\n                    exit = true;\n                    break;\n                }\n                if (code >= dic.length) {\n                    dic.push(dic[last].concat(dic[last][0]));\n                }\n                else if (last !== clearCode) {\n                    dic.push(dic[last].concat(dic[code][0]));\n                }\n                for (const item of dic[code]) {\n                    const { r, g, b, a } = getColor(item);\n                    image.data.set([r, g, b, a], (pixelPos += 4));\n                }\n                if (dic.length >= 1 << size && size < 0xc) {\n                    size++;\n                }\n            }\n        }\n        frame.image = image;\n        frame.bitmap = await createImageBitmap(image);\n        progressCallback?.((byteStream.pos + 1) / byteStream.data.length, getFrameIndex(false) + 1, frame.image, { x: frame.left, y: frame.top }, { width: gif.width, height: gif.height });\n    }\n}\nasync function parseBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback) {\n    switch (byteStream.nextByte()) {\n        case 59:\n            return true;\n        case 44:\n            await parseImageBlock(byteStream, gif, avgAlpha, getFrameIndex, getTransparencyIndex, progressCallback);\n            break;\n        case 33:\n            parseExtensionBlock(byteStream, gif, getFrameIndex, getTransparencyIndex);\n            break;\n        default:\n            throw new EvalError(\"undefined block found\");\n    }\n    return false;\n}\nexport function getGIFLoopAmount(gif) {\n    for (const extension of gif.applicationExtensions) {\n        if (extension.identifier + extension.authenticationCode !== \"NETSCAPE2.0\") {\n            continue;\n        }\n        return extension.data[1] + (extension.data[2] << 8);\n    }\n    return NaN;\n}\nexport async function decodeGIF(gifURL, progressCallback, avgAlpha) {\n    if (!avgAlpha)\n        avgAlpha = false;\n    const res = await fetch(gifURL);\n    if (!res.ok && res.status === 404) {\n        throw new EvalError(\"file not found\");\n    }\n    const buffer = await res.arrayBuffer();\n    const gif = {\n        width: 0,\n        height: 0,\n        totalTime: 0,\n        colorRes: 0,\n        pixelAspectRatio: 0,\n        frames: [],\n        sortFlag: false,\n        globalColorTable: [],\n        backgroundImage: new ImageData(1, 1, { colorSpace: \"srgb\" }),\n        comments: [],\n        applicationExtensions: [],\n    }, byteStream = new ByteStream(new Uint8ClampedArray(buffer));\n    if (byteStream.getString(6) !== \"GIF89a\") {\n        throw new Error(\"not a supported GIF file\");\n    }\n    gif.width = byteStream.nextTwoBytes();\n    gif.height = byteStream.nextTwoBytes();\n    const packedByte = byteStream.nextByte(), globalColorTableFlag = (packedByte & 0x80) === 0x80;\n    gif.colorRes = (packedByte & 0x70) >>> 4;\n    gif.sortFlag = (packedByte & 8) === 8;\n    const globalColorCount = 1 << ((packedByte & 7) + 1), backgroundColorIndex = byteStream.nextByte();\n    gif.pixelAspectRatio = byteStream.nextByte();\n    if (gif.pixelAspectRatio !== 0) {\n        gif.pixelAspectRatio = (gif.pixelAspectRatio + 0xf) / 0x40;\n    }\n    if (globalColorTableFlag) {\n        gif.globalColorTable = parseColorTable(byteStream, globalColorCount);\n    }\n    const backgroundImage = (() => {\n        try {\n            return new ImageData(gif.width, gif.height, { colorSpace: \"srgb\" });\n        }\n        catch (error) {\n            if (error instanceof DOMException && error.name === \"IndexSizeError\") {\n                return null;\n            }\n            throw error;\n        }\n    })();\n    if (backgroundImage == null) {\n        throw new Error(\"GIF frame size is to large\");\n    }\n    const { r, g, b } = gif.globalColorTable[backgroundColorIndex];\n    backgroundImage.data.set(globalColorTableFlag ? [r, g, b, 255] : [0, 0, 0, 0]);\n    for (let i = 4; i < backgroundImage.data.length; i *= 2) {\n        backgroundImage.data.copyWithin(i, 0, i);\n    }\n    gif.backgroundImage = backgroundImage;\n    let frameIndex = -1, incrementFrameIndex = true, transparencyIndex = -1;\n    const getframeIndex = (increment) => {\n        if (increment) {\n            incrementFrameIndex = true;\n        }\n        return frameIndex;\n    };\n    const getTransparencyIndex = (newValue) => {\n        if (newValue != null) {\n            transparencyIndex = newValue;\n        }\n        return transparencyIndex;\n    };\n    try {\n        do {\n            if (incrementFrameIndex) {\n                gif.frames.push({\n                    left: 0,\n                    top: 0,\n                    width: 0,\n                    height: 0,\n                    disposalMethod: 0,\n                    image: new ImageData(1, 1, { colorSpace: \"srgb\" }),\n                    plainTextData: null,\n                    userInputDelayFlag: false,\n                    delayTime: 0,\n                    sortFlag: false,\n                    localColorTable: [],\n                    reserved: 0,\n                    GCreserved: 0,\n                });\n                frameIndex++;\n                transparencyIndex = -1;\n                incrementFrameIndex = false;\n            }\n        } while (!(await parseBlock(byteStream, gif, avgAlpha, getframeIndex, getTransparencyIndex, progressCallback)));\n        gif.frames.length--;\n        for (const frame of gif.frames) {\n            if (frame.userInputDelayFlag && frame.delayTime === 0) {\n                gif.totalTime = Infinity;\n                break;\n            }\n            gif.totalTime += frame.delayTime;\n        }\n        return gif;\n    }\n    catch (error) {\n        if (error instanceof EvalError) {\n            throw new Error(`error while parsing frame ${frameIndex} \"${error.message}\"`);\n        }\n        throw error;\n    }\n}\nexport function drawGif(data) {\n    const { context, radius, particle, delta } = data, image = particle.image;\n    if (!image?.gifData || !image.gif) {\n        return;\n    }\n    const offscreenCanvas = new OffscreenCanvas(image.gifData.width, image.gifData.height), offscreenContext = offscreenCanvas.getContext(\"2d\");\n    if (!offscreenContext) {\n        throw new Error(\"could not create offscreen canvas context\");\n    }\n    offscreenContext.imageSmoothingQuality = \"low\";\n    offscreenContext.imageSmoothingEnabled = false;\n    offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n    if (particle.gifLoopCount === undefined) {\n        particle.gifLoopCount = image.gifLoopCount ?? defaultLoopCount;\n    }\n    let frameIndex = particle.gifFrame ?? defaultFrame;\n    const pos = { x: -image.gifData.width * half, y: -image.gifData.height * half }, frame = image.gifData.frames[frameIndex];\n    if (particle.gifTime === undefined) {\n        particle.gifTime = initialTime;\n    }\n    if (!frame.bitmap) {\n        return;\n    }\n    context.scale(radius / image.gifData.width, radius / image.gifData.height);\n    switch (frame.disposalMethod) {\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n        case 0:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            break;\n        case 1:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            break;\n        case 2:\n            offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n            context.drawImage(offscreenCanvas, pos.x, pos.y);\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n            if (!image.gifData.globalColorTable.length) {\n                offscreenContext.putImageData(image.gifData.frames[firstIndex].image, pos.x + frame.left, pos.y + frame.top);\n            }\n            else {\n                offscreenContext.putImageData(image.gifData.backgroundImage, pos.x, pos.y);\n            }\n            break;\n        case 3:\n            {\n                const previousImageData = offscreenContext.getImageData(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.drawImage(frame.bitmap, frame.left, frame.top);\n                context.drawImage(offscreenCanvas, pos.x, pos.y);\n                offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n                offscreenContext.putImageData(previousImageData, origin.x, origin.y);\n            }\n            break;\n    }\n    particle.gifTime += delta.value;\n    if (particle.gifTime > frame.delayTime) {\n        particle.gifTime -= frame.delayTime;\n        if (++frameIndex >= image.gifData.frames.length) {\n            if (--particle.gifLoopCount <= defaultLoopCount) {\n                return;\n            }\n            frameIndex = firstIndex;\n            offscreenContext.clearRect(origin.x, origin.y, offscreenCanvas.width, offscreenCanvas.height);\n        }\n        particle.gifFrame = frameIndex;\n    }\n    context.scale(image.gifData.width / radius, image.gifData.height / radius);\n}\nexport async function loadGifImage(image) {\n    if (image.type !== \"gif\") {\n        const { loadImage } = await import(\"../Utils.js\");\n        await loadImage(image);\n        return;\n    }\n    image.loading = true;\n    try {\n        image.gifData = await decodeGIF(image.source);\n        image.gifLoopCount = getGIFLoopAmount(image.gifData) ?? defaultLoopCount;\n        if (!image.gifLoopCount) {\n            image.gifLoopCount = Infinity;\n        }\n    }\n    catch {\n        image.error = true;\n    }\n    image.loading = false;\n}\n","import { errorPrefix } from \"@tsparticles/engine\";\nimport { replaceImageColor } from \"./Utils.js\";\nimport { drawGif } from \"./GifUtils/Utils.js\";\nconst double = 2, defaultAlpha = 1, sides = 12, defaultRatio = 1;\nexport class ImageDrawer {\n    constructor(engine) {\n        this.loadImageShape = async (imageShape) => {\n            if (!this._engine.loadImage) {\n                throw new Error(`${errorPrefix} image shape not initialized`);\n            }\n            await this._engine.loadImage({\n                gif: imageShape.gif,\n                name: imageShape.name,\n                replaceColor: imageShape.replaceColor ?? false,\n                src: imageShape.src,\n            });\n        };\n        this._engine = engine;\n    }\n    addImage(image) {\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        this._engine.images.push(image);\n    }\n    draw(data) {\n        const { context, radius, particle, opacity } = data, image = particle.image, element = image?.element;\n        if (!image) {\n            return;\n        }\n        context.globalAlpha = opacity;\n        if (image.gif && image.gifData) {\n            drawGif(data);\n        }\n        else if (element) {\n            const ratio = image.ratio, pos = {\n                x: -radius,\n                y: -radius,\n            }, diameter = radius * double;\n            context.drawImage(element, pos.x, pos.y, diameter, diameter / ratio);\n        }\n        context.globalAlpha = defaultAlpha;\n    }\n    getSidesCount() {\n        return sides;\n    }\n    async init(container) {\n        const options = container.actualOptions;\n        if (!options.preload || !this._engine.loadImage) {\n            return;\n        }\n        for (const imageData of options.preload) {\n            await this._engine.loadImage(imageData);\n        }\n    }\n    loadShape(particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const image = this._engine.images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            void this.loadImageShape(imageData).then(() => {\n                this.loadShape(particle);\n            });\n        }\n    }\n    particleInit(container, particle) {\n        if (particle.shape !== \"image\" && particle.shape !== \"images\") {\n            return;\n        }\n        if (!this._engine.images) {\n            this._engine.images = [];\n        }\n        const images = this._engine.images, imageData = particle.shapeData;\n        if (!imageData) {\n            return;\n        }\n        const color = particle.getFillColor(), image = images.find((t) => t.name === imageData.name || t.source === imageData.src);\n        if (!image) {\n            return;\n        }\n        const replaceColor = imageData.replaceColor ?? image.replaceColor;\n        if (image.loading) {\n            setTimeout(() => {\n                this.particleInit(container, particle);\n            });\n            return;\n        }\n        void (async () => {\n            let imageRes;\n            if (image.svgData && color) {\n                imageRes = await replaceImageColor(image, imageData, color, particle);\n            }\n            else {\n                imageRes = {\n                    color,\n                    data: image,\n                    element: image.element,\n                    gif: image.gif,\n                    gifData: image.gifData,\n                    gifLoopCount: image.gifLoopCount,\n                    loaded: true,\n                    ratio: imageData.width && imageData.height\n                        ? imageData.width / imageData.height\n                        : image.ratio ?? defaultRatio,\n                    replaceColor: replaceColor,\n                    source: imageData.src,\n                };\n            }\n            if (!imageRes.ratio) {\n                imageRes.ratio = 1;\n            }\n            const fill = imageData.fill ?? particle.shapeFill, close = imageData.close ?? particle.shapeClose, imageShape = {\n                image: imageRes,\n                fill,\n                close,\n            };\n            particle.image = imageShape.image;\n            particle.shapeFill = imageShape.fill;\n            particle.shapeClose = imageShape.close;\n        })();\n    }\n}\n"],"names":["InterlaceOffsets","InterlaceSteps","ByteStream","constructor","bytes","this","pos","data","Uint8ClampedArray","getString","count","slice","length","reduce","acc","curr","String","fromCharCode","nextByte","nextTwoBytes","readSubBlocks","blockString","size","readSubBlocksBin","len","offset","blockData","Uint8Array","i","skipSubBlocks","increment","noData","origin","x","y","defaultFrame","half","initialTime","firstIndex","defaultLoopCount","parseColorTable","byteStream","colors","push","r","g","b","async","parseBlock","gif","avgAlpha","getFrameIndex","getTransparencyIndex","progressCallback","frame","frames","left","top","width","height","packedByte","localColorTableFlag","interlacedFlag","sortFlag","reserved","localColorCount","localColorTable","getColor","index","globalColorTable","a","image","ImageData","colorSpace","error","DOMException","name","EvalError","minCodeSize","imageData","clearCode","readBits","bytePos","bitPos","code","dic","pass","pixelPos","lineIndex","exit","last","concat","item","set","bitmap","createImageBitmap","parseImageBlock","GCreserved","disposalMethod","userInputDelayFlag","transparencyFlag","delayTime","transparencyIndex","applicationExtension","identifier","authenticationCode","applicationExtensions","comments","plainTextData","charSize","foregroundColor","backgroundColor","text","parseExtensionBlock","drawGif","_particle$gifFrame","context","radius","particle","delta","gifData","offscreenCanvas","OffscreenCanvas","offscreenContext","getContext","Error","_image$gifLoopCount","imageSmoothingQuality","imageSmoothingEnabled","clearRect","undefined","gifLoopCount","frameIndex","gifFrame","gifTime","scale","drawImage","putImageData","backgroundImage","previousImageData","getImageData","value","loadGifImage","type","loading","_getGIFLoopAmount","gifURL","res","fetch","ok","status","buffer","arrayBuffer","totalTime","colorRes","pixelAspectRatio","globalColorTableFlag","globalColorCount","backgroundColorIndex","copyWithin","incrementFrameIndex","getframeIndex","newValue","Infinity","message","decodeGIF","source","extension","NaN","getGIFLoopAmount","loadImage","ImageDrawer","engine","loadImageShape","_imageShape$replaceCo","_engine","errorPrefix","imageShape","replaceColor","src","addImage","images","draw","opacity","element","globalAlpha","ratio","diameter","getSidesCount","init","container","options","actualOptions","preload","loadShape","shape","shapeData","find","t","then","particleInit","_imageData$replaceCol","color","getFillColor","setTimeout","_imageData$fill","_imageData$close","imageRes","_image$ratio","svgData","replaceImageColor","loaded","fill","shapeFill","close","shapeClose"],"sourceRoot":""}